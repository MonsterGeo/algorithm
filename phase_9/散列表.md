# 散列表

链表固然好，但增删改查的时间在$\Theta(n)$，而散列表可以达到$O(1)$的时间（若为双链表实现则删除也是O(1)）。

## 直接寻址

给定关键字的全域U，一种寻址方法是直接根据关键字找到元素。这是有效简单的方法。假设某应用使用到一个集合，每个元素都是全域$U = \{0,1,2,\cdots,m-1\}$中的一个关键字，我们假设m不大，并且元素俩俩互异。

为了表示这个集合，我们使用一个数组来装载元素，那么这个数组我们叫做直接寻址表。记为```T[0..m-1]```。数组中的每个位置称为槽，是用来存放数据的，那么每个槽对应一个全域U中的关键字，比如，槽k指向集合中一个关键字为k的元素，即T[k] = 槽k中存放的元素。若集合中不存在关键字为k的元素，则T[k] = NIL,

```
DIRECT-ADDRESS-SEARCH(T,k)
1| return T[k]

DIRECT-ADDRESS-INSERT(T,x)
1| T[x,key] = x

DIRECT-ADDRESS-DELETE(T,x)
1| T[x,key] = NIL
```

上述的操作都只需要O(1)的时间。

## 散列表

直接寻址并不太好用，注意到全域U很大的时候，储存一张大小为|U|的表不太实际。甚至不太可能。另一方面，实际存储的关键字集合K相对U来说可能很小，使得大部分分配给T的空间被浪费掉

散列表的好处是，当关键字集合|K| <|U|，散列表需要的存储空间比直接寻址要小得多。特别的，散列表的储存需求可以压缩到$\Theta(|K|)$。

在直接寻址的方式下，具有关键字k的元素存储在槽k中。在散列的方式下，该元素在h(k)中，即通过散列函数h，由关键字k计算出槽的位置。这里h将关键字的全域U映射到散列表T[0..m-1]的槽位上

$$
h:U\to \{0,1,\cdots,m-1\}
$$

这里散列表的大小m一般比$|U|$小很多。但这也有一个问题，那就是函数$h$并非双射，函数是满射。存在两个关键字映射到同一个槽中的情况。

理想的情况是避免这种冲突。在这一点上，一个想法是使$h$尽可能的随机，避免冲突或者冲突次数最小化。但函数应该是能够确定的，不然下次$h(k) \neq h(k)$。

另一方面，既然有冲突的问题，我们也需要解决冲突的方法，我们成为链接法。在之后还有一种叫开放寻址法的方法。

在链接法中，我们把散列到同一槽位的所有元素储存在一个链表中，槽j中含有一个指针，指向储存所有散列到j的元素的链表的表头，若不存在这样的元素，则槽$j$ = NIL。

上述的散列表还是容易实现的

```
CHAINED-HASH-INSERT(T,x)
1| insert x at the head of list T[h(x,key)]

CHAINED-HASH-SEARCH(T,k)
1| search for an element with key k in list T[h(k)]

CHAINED-HASH-DELETE(T,x)
1| delete x from the list T[h(x,key)]
```

插入操作的时间是O(1)，若散列表中的链表都是双向的，则删除一个元素的时间可以在O(1)实现。若是单链表，则删除和查找的运行时间相同。