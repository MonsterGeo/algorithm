# 开放寻址法

开放寻址法的所有元素都在散列表中，这意味着你要找某个元素的时候要系统的检查所有表项里的元素，知道查到需要的元素。或者最终发现该元素并不在表里。因此，散列表或许会被填满.


开放寻址法可以不使用链表，这样可以省去指针存放的空间，使得我们可以用同样的空间提供更多的槽，潜在的减少了冲突，提高检索速度。

使用开放寻址插入一个元素，需要连续的检查散列表，我们称为 **探查**。直到找到一个空槽来存放待插入的关键字。检查的顺序不一定是按照自然顺序[^1]，因为这种情况下的时间为$\Theta(n)$。而是依赖待插入的关键字，为了要确定探查什么槽，我们将散列函数扩充，使之包含探查号(从0开始)作为第二个输入参数，这样，散列函数就变成

$$
h: U\times \{0,1,\cdots,m-1\} \to \{0,1,\cdots,m-1\}
$$

对每个关键字$k$，开放寻址的探查序列

$$
\left<h(k,0),h(k,1),\cdots,h(k,m-1)\right>
$$
是$\{0,1,\cdots,m-1\}$的一个排列，

等一下给出的伪代码，每一个表位最终都可以考虑为用来插入新关键字的槽，我们会假设散列表$T$为无卫星数据[^2]的关键字。关键字$k$等同于包含关键字$k$的元素。每个槽或包含一个关键字，或是空的则为$NIL$。```HASH-INSERT```过程以一个散列表$T$和一个关键字$k$为输入，其要么返回关键字$k$的储存槽位，要么因为散列表已满而返回出错标志：

```C
HASH-INSERT(T,k)
1| i = 0
2| repeat
3|   j = h(k,i)
4|   if T[j] == NIL
5|      T[j] = k
6|      return j
7|   else i = i+1
8|  until i == m
9|  error "hash table overflow"
```

```C
int HASH_INSERT(int arr[],int k,int size){
    int i = 0;
    int j = HASH_fun(arr, k);
    int m = size;
    while(i <= m){
        if(arr[j] == NULL)
        {
            arr[j] = k;
            return j;
        }
        else i++;
    }
    printf("Hash table is full\n");
    return 0;
}
```
```line-numbers
HASH-SEARCH(T,k)
i = 0
repeat
    j = h(k,j)
    if T[j] == k
        return j
        i = i+1
until T[j] == NIL or i == m
return NIL
```


```C
int HASH_SEARCH(int arr[],int k,int size){
    int i = 0;
    int j = HASH_fun(arr, k);
    int m = size;
    while(i <= m){
        if(arr[j] == k)
        {
            return j;
        }
        else i++;
    }
    printf("Element not found\n");
    return 0;
}
```

但是删除操作就很困难了，当我们从槽$i$删除关键字的时候，不能仅将其置NIL表示空，这样会判定槽$i$是占用的，$k$会直接插入到后面的位置，如果将槽$i$的关键字删掉之后就无法搜到$k$了，因此我们需要用一个特定的值来代替NIL标记该槽。

[^1]: 即按照$1,2,\cdots,m-1$的顺序。

[^2]: 通过关键字找到的槽储存的元素叫卫星数据