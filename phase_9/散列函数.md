# 散列函数

一个好的散列函数应该近似地满足简单均匀散列假设。即每个关键字都应该等可能的散列到$m$个槽中的任一一个。并与其他关键字散列到哪个槽里无关。但这一条并非可验证，因为我们不知道关键字服从什么概率分布。并且关键字都不是独立的。

但我们可以人为控制概率分布，假设我们对一些关键字总结出服从某个分布，例如：若关键字都是随机的实数$k$，他们独立均匀分布于$0\leq k < 1$的范围中，那么散列函数
$$
h(k) = \lfloor mk \rfloor
$$
就能简单的满足均匀散列的假设条件。因为服从均匀分布。

用模就是一种不错的方法，注意对同余类$I_m$，$m$是素数，那么这个方法有一些比较好的性质，对任意整数$a,b$，$a \equiv b \mod m$当且仅当$a,b$具备相同的余数。可以用这性质来做散列函数。

## 将关键字转换为自然数

多数散列函数都假定关键字的全域$\mathbb{N} = \{0,1,2,\cdots\}$，所以，如果给定的关键字并非自然数，那么就需要找一种方法来转为自然数。例如ASCLL编码，标识符$pt = (112,116)$。然后我们用$128$做基数，$pt = (112 \times 128) + 116 = 14452$。当然这只是一种方法，我们可以设计出许多类似的算法将每个关键字转化为一个自然数。

## 除法散列法

本小节使用模运算来设计散列函数。我们通过取$k/m$的余数，将$k$映射到$m$个槽中的某一个，那么散列函数如下：

$$
h(k) = k\mod m
$$

若散列表大小为$m = 12$，所给关键字$k = 100$，则$h(k) = 4$。这些操作都是$O(1)$

但这也有缺陷，注意到对$m = 2^k$，此时注意到这是素域$P_2$的扩域，$a\in P_2$都有任意的$2a = 0$，因此$2^k = 0$。这是不行的，因为会映射到同一个槽。也就是说，对任意的素数$p$去取$a$的余，最好避免$a^k$此类的幂次。

## 乘法散列

乘法散列函数构造由2个部分组成，第一步，对关键字$k$乘上常数$A(0 < A < 1)$，并提取$kA$的小数部分，第二，用$m$乘上$kA$的小数部分。再向下取整。可以用$\mod 1$表示，即除以自身剩下的数。

$$
h(k) =- \lfloor m(kA \mod 1) \rfloor
$$

其中$kA\mod 1 = kA - \lfloor kA \rfloor$

这是改良版的除法散列，在这里，我们对$m$的选择不是特别关键，一般选择它为$2$的某个幂次。

现在，假设计算机的字在二进制表示下长度为$w$，并且$k$是可以用一个16位的变量储存的数字。我们限制数$A$是一个小数，它由一个跟$2^w$同长度的整数，但满足$ 0 < s < 2^w$通过$s/2^w$的形式生成。

先用$w$位整数$s = A \cdot 2^w$乘以$k$，结果就是一个长度为$2w$的整数，可以表示为$r_1 2^w + r_0$，其中$r_0$是乘积的低位。最后，我们根据$m = 2^p$中的$p$，在$r_0$中选取对应的位数就是散列值了。

该方法理论对任意$A$都适用，但对于一些值效果更好，比如 *Knuth* 认为

$$
A = (\sqrt{5}-1)/2 \approx 0.6180339887
$$
是一个非常不错的数。

我们给一个例子，假设$k = 123~ 456$，$p = 14$，那么$m = 2^{14} = 16384$，选定长度为$w = 32$的字，我们根据*Knuth*的建议选取$A$是跟$(\sqrt{5}-1)/2$接近的形如$s/2^w$的分数，那么$A = 2 ~654 ~435~ 769/2^{32}$就有$k \times s=(76~300) \times 2^{32} + 17612864 $，选取$17612864$的前14位（注意补位到整个字节为32位长度），就有$h(k) = 67$

## 全域散列法

如果让一个恶意的对手来针对某个特定的散列函数选择散列的关键字，那么它将$n$个关键字全部散列到同一个槽中，使得平均的检索时间达到$\Theta(n)$，任何散列都可能会出现这种情况，因此我们的改进方法就是随机的选择散列函数，使得独立于要储存的关键字。这种方法脚全域散列，不管对手选择什么样的关键字，其平均性能都很好。

和排序算法一样，我们也将散列函数的选择随机化。随机化保证了没有哪一种输入会始终导致最坏情况性能。但同时也相当于选取最坏散列情况的概率也是等可能的。

设$K$是一组有限散列函数的集合，他将给定的关键字全域$U$映射到$\{0,1,\cdots,m-1\}$中。这样的一个函数组成为全域的，如果每一对不同的关键字$k,l \in U$，满足$h(k) = h(l)$的散列函数$h \in K$至多为$\mid K\mid /m$。意思是若$k\neq l$，两者冲突的概率不大于$1/m$。这正好是从集合$\{0,1,\cdots,m-1\}$中随机独立的挑选$h(k),h(l)$冲突的概率。

我们来证明，全域散列函数类的平均性能是比较好的，我们使用$n_i$来表示链表$T[i]$的长度

**定理：** 若$h$是全域散列函数中的一个，将$n$个关键字散列到一个大小为$m$的表$T$中，并使用链表处理冲突，若关键字$k$不在表中，则$k$被散列到其中链表的期望长度$E[n_{h(k)}]$至多为$\alpha = n/m$。若关键字$k$在表中，则包含关键字链表的期望长度$E[n_{h(k)}]$至多为$1+\alpha$。

**证明：** 此处的期望值和散列函数的选择有关，并且不依赖于任何有关关键字分布的假设。对于每对不同的关键字$k,l$，定义随机变量治时期$X_{ij} = I(h(k) = h(l))$，因为由全域散列函数定义，一堆关键字发生冲突的概率至多为$1/m$。则$\Pr(X_{ij}) \leq 1/m$。那么

$$
E[X_{kj}] = 1\cdot 1/m + 0 *\Pr(\hat{X_{kj}}) \leq 1/m
$$

然后，对每个关键字$k$，定义随机变量$Y_k$，它表示与$k$散列到同一槽位的非$k$的其他关键字的数目。则
$$
Y_k = \sum_{l\in T,l\neq k} X_{kl}
$$

那么它的期望$E[Y_k] \leq \sum_{l\in T,l\neq k}\frac{1}{m}$

然后我们分情况讨论，若$k\notin T$，则$n_{h(k)} = Y_k$，并且$\mid (l,l\in T 且 l\neq k)\mid = n$，于是$E[n_{h(k)}] = E[Y_k] \leq n/m = \alpha$。

另一方面，若$k \in T$，并且关键字$k$出现再链表$T(h(k))$中，且计数$Y_k$中并没有包括关键字$k$，因而$n_{h(k)} = Y_k+1$，并且$\mid (l,l\in T且l \neq k)\mid = n-1$。那么$E[n_{h(k)}] = E[Y_k] + 1 \leq (n-1)/m + 1 = 1 + \alpha$



## 设计一个全域散列函数

本小节将用到许多代数知识。

给定一个较大的素数$p$，使得每一个可能的关键字$k$都落在$0$到$p-1$的范围内（包括0和p-1）。用$Z_p $表示集合$\{0,1,\cdots,p-1\}$，$Z_p^*$表示集合$\{1,2,\cdots,p-1\}$。前者为模$p$加法群，后面是乘法群。

现在，对于任何$\alpha\in Z_p$，定义散列函数$h_{ab}$。利用一次线性变换，再进行$\mod p$和$\mod m$的运算，有
$$
h_{ab}(k) = ((ak + b) \mod p) \mod m
$$

例如，若$p = 17$和$m = 6$，则有$h_{3,4}(8) = 5$，这样的散列函数构成集合簇为
$$
K_{pm} = \{h_{ab} : a\in Z^{*}_p,b\in Z_p\}
$$

每一个散列函数$h_{ab}$都将$Z_p \to Z_m$。这样构造的好处就是$m$可以是随意的，不用选为素数。对$a$来说有$p-1$种选择，$b$有$p$个，那么一共有$p(p-1)$个散列函数。

我们来证明这种方法生成的散列函数是全域的。

**定理：** 由$h_{ab}$生成的散列函数和函数簇$K_{pm}$是全域的。

**证明：** 考虑$Z_p$中的两个不同关键字$k,l$即$k\neq l$。对给定的散列函数$h_{ab}$，设

$$
\begin{array}{lll}
    r &=& (ak+b)\mod p\\
    s &=& (al+b)\mod p
\end{array}
$$

首先证明$r \neq s$。

$$
r-s \equiv a(k-l)\mod p
$$

由于$p$是素数，并且$k\neq l$。那么$r-s \neq 0$。所以$r \neq s$。因此，他们的乘积也不会等于0，于是在计算任何$h_{ab}\in K_{pm}$的时候，输入不同的$k,l$都会产生不同的值。在模p层面上不存在冲突。这由模性质保证。

另一方面，数对$(a,b) ,a\neq 0$有$p(p-1)$种可能，那么每一种都会产生不同的结果对$(r,s)(r\neq s)$。这是因为给定$r,s$后可以解出$a,b$

$$
\begin{array}{lll}
    a &=& ((r-s)(k-l)^{-1}\mod p)\mod p\\
    b &=& (r-ak)\mod p
\end{array}
$$

上述的式子比较冗杂，它是这么得到的

注意
$$
r - s \equiv a(k-l)\mod p
$$

其中$p$是素数，注意对于任意同于类$I_p$，$I_p$是域，因此存在乘法逆元。那么可以这样变换

$$
(r-s)(k-l)^{-1} \equiv a \mod p
$$

有

$$
a \equiv (r-s)(k-l)^{-1}\mod p
$$

按定义展开，得到

$$
a \mod p = (r-s)(k-l)^{-1}\mod p
$$

有
$$
a = ((r-s)(k-l)^{-1}\mod p)\mod p
$$

但实际上这不必要，因为在第一个$\mod p$之后，只会出现在$\{1,2,\cdots,p-1\}$中的任意一个元素。可以直接简化为
$$
a = (r-s)(k-l)^{-1}\mod p
$$

所以我们可以发现，有一个一一对应恭喜，对任意输入$k,l$，若从$Z_p^* \times Z_p$中随机选择$(a,b)$，那么数对$(r,s)$等可能的为任意不同值对(mod p)

回到证明上来，为了证明是全域散列，我们要证明冲突概率小于$1/m$

现在，当$r,s$为不同值(随机选择并mod p),不同关键字$k,l$发生冲突的概率等价于$r \equiv s \mod m$的概率，对于给定的$r$值，$s$的可能为余下的$p-1$种。其中满足$s \neq r$且$ s\equiv r \mod m$的s数目至多为

$$
\lceil p/m \rceil -1 \leq ((p+m-1)/m)-1 = (p-1)/m
$$

注意对任意$p = 7, m= 3$，那么$p$落在$m$中的元素就有$\lceil p/m\rceil = \lceil 7/3\rceil = 2个$，那么满足$r,s$在$m$和$p$中同余的数就是$p/m$的上取整-1（排除自己）。

那么冲突概率就是$$
(p-1)/m  * 1/m = 1/m
$$

即
$$
\Pr(h_{ab}(k)) = h_{ab}(l) \leq 1/m
$$

因此$K_{pm}$是全域的。