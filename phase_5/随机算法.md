# 第五章

本章介绍概率分析和随机算法。这节的伪代码较简单，因此不在此写任何C代码

## 雇佣问题

假如你要雇佣一名新的办公助理，你先前的雇佣尝试都失败了，于是你决定找一个雇佣代理，雇佣代理每天给你推荐一个应聘者。然后你面试这个人，在考虑是否要雇佣他。你必须给雇佣代理一笔小费用，以便面试应聘者。然而要真的雇佣一个应聘者需要花费更多的钱，因为你必须辞掉现在的办公助理，还要付一笔钱给雇佣代理。你承诺在任何时候，都要找最合适的人来担任这项职务，因此你决定在面试完每个应聘者后，若该应聘者必目前的办公助理更合适，就会辞掉当前的助理，然后聘用新的。你愿意为该策略付费，但希望能够估算该费用是多少。

接下来我们给出的HIRE-ASSISTANT过程以伪代码表示该雇佣策略。假设应聘办公助理的候选人编号为1到n。该过程中假设你能在面试完应聘者i后，决定i是否是你目前见过的最佳人选，初始化的时候，该过程创建应聘者0，他是虚拟的应聘者，并且必所有应聘者都差

```line-numbers
HIRE-ASSISTANT(n)
best = 0  //0号是最差的应聘者
for i = 1 to n
    面试应聘者i
    if 应聘者i 比 best更好
        best = i
        雇佣应聘者i
```

我们现在不关注程序的运行时间，我们现在关注的是分析面试和雇佣产生的费用，但使用的方法和分析运行时间是差不多的，都是分析基本操作的执行次数。

面试的费用较低，设为$c_i$，但是雇佣的费用较高，设为$c_h$，设$m$是雇佣的人数，那么该算法的最低费用是$O(c_in+c_hm)$，不管雇佣多少人，总会面试$n$个应聘者，这就是面试产生的$c_in$费用，所以我们专主$c_hm$，即雇佣的费用。这个量每次运行的时候都不同

### 最坏情况分析

在最坏情况下，我们实际上雇佣了每个面试的应聘者，此时雇佣了$n$次，那么雇佣费用就是$O(c_h n)$，但，应聘者总不是按照以质量递增的次序出现。事实上我们也不知道这个次序是什么。所以如何考虑这一典型或者平均的情形下会发生什么是下述分析性要做的事情

### 概率分析

雇佣问题中，我们假定应聘者是以随机顺序出现的。这一假设告诉我们不需要老老实实从1到n去做排序，我们可以随时把任意两个应聘者做比较。也就是说存在一个1到n上的全序关系。用rank(i)表示第i位应聘者即可。并约定一个较高的名次对应一个更好的应聘者那么<rank(1),$\cdots$,rank(n)>是序列<1,2,$\cdots$,n>的一个排列，这个排列存在$n!$种，并且每种出现的可能概率都是相等的。

### 随机算法

如果一个算法的行为不仅由输入决定，并且也由随机数生成器决定，则说这个算法是随机的。我们假设有一个可以自由使用的生成器RANDOM，调用RANDOM(a,b)将返回一个介于a到b的整数，例如RANDOM(0,1)有1/2的概率产出0或者1。但在实践中我们只有伪随机数生成器，他是确定性的算法，但返回值在统计上看起来是随机的。

我们分析随机算法的运行时间是通过期望值的，其中输入值由随机数生成器产生，我们将随机算法的运行时间称为期望运行时间，以此区分这类算法和那些输入是随机的算法。若概率分布是算法的输入时，我们只讨论平均情况运行实践，当算法本身随机选择时，我们讨论其期望运行时间。

## 指示器随机变量

为了分析雇佣问题在内的许多算法，我们采用指示器随机变量。它为概率和期望之间的转换提供了一个便利的方法，给定一个样本空间$S$和事件$A$，那么事件$A$对应的指示器随机变量$I\{A\}$定义为

$$
I\{A\} = \left\{\begin{array}{lcl}
    1 & & \text{if } A\text{ happen}\\
    0 & & \text{if }A \text{ doesn't happen}
\end{array}\right.
$$

一个简单的例子，我们确定掷一枚硬币时正面朝上的期望次数，在这里，样本空间$S = \{H,T\}$，其中$H$是正面，$T$是反面。并且$\Pr(H) = \Pr(T) = 1/2$.若正面朝上，则值为1，否则为0，记为

$$
X_H = I(H) =\begin{cases}
    1 & \text{if } H \text{ happen}\\
    0 & \text{if } T \text{ happen}
\end{cases}
$$

掷硬币时，正面朝上的期望次数就是指示器变量$X_H$的期望值

$$
E[X_H] = 1\cdot \Pr(H) + 0\cdot \Pr(T) = 1\cdot\frac{1}{2}+0\cdot\frac{1}{2} = \frac{1}{2}
$$

它的意思是掷硬币的次数越多，掷硬币得到正面的总值就越接近1/2

**引理:1** 给定样本空间$S$和$S$上的事件$A$，令$X_A = I(A)$，那么$E[X_A] = \Pr(A)$

**Proof** ：
$$
E[X_A] = 1\cdot \Pr(A)+0\cdot \Pr(\stackrel{-}{A}) = \Pr(A)
$$

其中$\stackrel{-}{A} = S-A$

期望是一个好用的工具，特别是它的线性性质。设随机变量$X$表示$n$次抛硬币中出现正面的次数，那么

$$
X = \sum^n_{i = 1}X_i
$$

我们希望计算正面朝上次数的期望，所以对上面等式两边取期望，得到

$$
E[X] = E\left[\sum^n_{i=1}X_i\right]
$$
由期望的线性性质，那么$n$个随机变量总和的期望值等价于n个期望值的总和，就有

$$
E[X] = E\left[\sum^n_{i=1}X_i\right] = \sum^n_{i=1}E[X_i] = \sum^n_{i=1}\frac{1}{2} = n/2
$$

### 用指示器随机变量分析雇佣问题
为了使用指示器，我们首先需要定义随机变量，将其和每个雇佣者是否被雇佣对应。特别的，假设$X_i$表示第$i$个应聘者被雇佣这个事件的随机变量指示器，那么有

$$
X_i = I(应聘者被雇佣) = \begin{cases}
    1 & 如果i被雇佣\\
    0 & 如果i不被雇佣
\end{cases}
$$

以及$X = X_1+X_2+\cdots +X_n$

回到伪代码，伪代码中第6行，若应聘者i被聘用，说明i比i-1之前的所有应聘者都优秀，但我们假设应聘者是随机出现的，所以前i个应聘者中的任意一个都是等概率目前最有资格的，应聘者i比1到i-1更有资格的概率为1/i，因而也是1/i的概率被雇佣。由引理1，有
$$
E[X_i] = 1/i
$$

我们计算$E[X]$

$$
\begin{array}{ccc}
    E[X] &=& \sum^n_{i=1}E[X_i]\\
    &=& \sum^n_{i=1}\frac{1}{i}\\
    &=& \ln n +O(1)
\end{array}
$$

简单得知$\sum^n_{i=1}1/i > \int^n_11/i di = \ln(n)$，而$\sum^n_{i=1}1/i - \int^n_i 1/i di = \gamma$，$\gamma$是欧拉常数，因而用$O(1)$代替。

所以，尽管我们面试了n个人，但平均来说，我们只需要大约雇佣其中的$\ln n$个人即可。

**引理2：** 假设应聘者是随机次序出现的，算法HIRE-ASSISTANT总的雇佣费用在平均情况下为$O(c_h\ln n)$

**Proof** 利用引理2，这个平均人数大概是$\ln n$，加上雇佣费用，就是$O(c_h\ln n)$

现在的问题是，我们如何在代码中实现随机排序的应聘者。当然，我们先来设计一个随机排列数组的算法。我们将讨论两种随机方法。

给定一个数组$A$，他包含元素$1$到$n$，我们的目的是构造一个该数组的一个随机排列

通常的方法是对数组的每个元素A[i]赋予一个随机的优先级P[i]，然后根据优先级对数组$A$中的元素进行排序。例如，若初始数组A = [1,2,3,4]，随机选择的优先级P = [36,3,62,19]，那么产生一个新的数组B = [2,4,1,3]。因为第二个优先级最小，接着是第四个。我们将这个过程叫做PERMUTE-BY-SORTING


```line-numbers
PERMUTE-BY-SORTING
n = A.length
let P[1...n] be a new array
for i = 1 to n
    P[i] = RANDOM(1,n^3)
sort A, using P as sort keys
```

我们选取$n^3$是为了防止优先级重复。因为这些元素都唯一的概率至少是1-1/n。不过目前，我们都假设这些元素是唯一的。

我们还需要证明该过程是均匀随机排列，即该过程等可能的产生数字1~n的每一种排列

**引理3：** 假设所有优先级都不同，则过程PERMUTE-BY-SORING产生输入的均匀随机排列。

**Proof：** 我们考虑每个元素A[i]分配到第i个最小优先级的特殊排列开始，并证明这个概率是1/n!，对$i  = 1,2,\cdots,n$，设$E_i$是代表元素A[i]分配到第$i$个最小优先级的事件，然后我们对所有i计算事件$E_i$发生的概率，即

$$
\Pr(E_1\cap E_2\cap\cdots\cap E_{n-1}\cap E_n)
$$

这个公式又可以如下表示：
$$
\Pr(E_1) \cdot \Pr(E_2|E_1) \cdots \Pr(E_n|E_{n-1}\cap \cdots\cap E_1)
$$
即，先算出$E_1$的概率，然后算出$E_1$发生时$E_2$发生的概率，以此类推直到$E_n$，全部乘起来就是我们要算的概率了，这代表这些事情一起发生。现在$\Pr(E_1) = 1/n$，因为它是一个从n元素的集合中随机选取的优先级最小的概率。接着，那么$\Pr(E_2|E_1) = 1/(n-1)$，因为假定A[1]有最小优先级，那么只有剩下n-1个元素，从里面分配到第二小的概率就是$1/(n-1)$以此类推，那么对$i = 2,3,\cdots,n$，我们有$\Pr(E_i|E_{i-1}\cap\cdots\cap E_1) = 1/(n-i+1)$因此，归纳的有

$$
\Pr(E_1\cap E_2\cap\cdots\cap E_n) = \frac{1}{n}\frac{1}{n-1}\cdots\frac{1}{2}\frac{1}{1} = \frac{1}{n!}
$$

因此，获得等同排列的概率是$1/n!$。

当然，如果你学习过抽象代数，那么这有更简单的方法，注意到这是一个$n$元置换群，一共存在$n!$种排列，每个排列的概率都是$1/n!$

产生随机排列的一个更好的方法是原址排列给定数组。程序RANDOMIZE-IN-PLACE在O(n)时间内完成。在进行第i次迭代时，元素A[i]是从A[i]到A[n]中随机选取的。第i次迭代以后，A[i]将不会改变

```line-numbers
RANDOMIZE-IN-PLACE(A)
n = A.length
for i = 1 to n
    swap A[i] with A[RANDOM(i,n)]
```

着重讲4行，其实他就是将i和i到n上的随机一个数进行交换。我们将证明该过程是一个具有n个元素的k-排列，即n个元素中包含k个元素的序列并且不重复。它一共有$n!/(n-k)!$种可能的排列。

**引理4** RANDOMIZE-IN-PLACE是均匀随机排列

**Proof** 首先考虑初始化的情况，当$i = 1$，则对每个可能0排列，子数组A[1..0]包含这个排列的概率是$(n-i+1)/n! = 1$，该式子在第一次循环之前都成立

对归纳步骤，在第i次迭代之前，每种可能的(i-1)排列都出现在子数组A[1..i]中的概率为$(n-i+1)!/n!$

考虑一个特殊的排列$(x_1,\cdots,x_i)$，这个序列包含一个$i-1$个元素的序列$(x_1,\cdots,x_{i-1})$，接着算法在A[i]中放置值$x_i$。设$E_1$为前i-1次迭代中构造了特殊(i-1)排列的事件，而$E_2$表示在第$i$次迭代在A[i]放置$x_i$的事件。当$E_1$和$E_2$一起发生的时候，排列$(x_1,\cdots,x_i)$就在A[1..i]中，所以我们需要计算$\Pr(E_2\cap E_1)$。那么
$$
\Pr(E_2\cap E_1)=\Pr(E_2|E_1)\Pr(E_1)
$$

概率$\Pr(E_2|E_1) = 1/(n-i+1)$，因为$E_2$只需要放置一个元素。而$\Pr(E_1) = (n-i+1)!/n!$，所以

$$
\Pr(E_2\cap E_1)=\frac{1}{n-i+1}\frac{(n-i+1)!}{n!} = \frac{(n-i)!}{n!}
$$

最后，循环结束时，$i = n+1$，数组A[1..n]是一个给定n排列的概率为$(n-(n+1)+1)/n! = 0!/n! = 1/n!$。

所以这也是一个均匀随机排列。

