[toc]

# 算法基础


## 插入排序

我们的第一个算法是求解第一章中引入的排序问题

---

**输入：** n个数的一个序列$(a_1,a_2,\cdots,a_n)$
**输出：** 输出序列的一个排列$(a_1',a_2',\cdots,a'_n)$，满足$a_1' \leq a_2'\leq \cdots \leq a_n'$

---

，我们通常将算法描述为用一种伪代码书写的程序，该伪代码在许多方面类似于C、c++、 Java、 Python 或 Pascal。如果你学过这些语言中的任何一种，那么在阅读我们的算法时应该没有困难。伪代码与真码的区别在千，在伪代码中，我们使用最清晰、最简洁的表示方法来说明给定的算法。有时最清晰的表示方法是英语，所以如果你遇到一个英文短语或句子嵌入在一段真码中就不要吃惊。伪代码与真码的另一个区别是伪代码通常不关心软件工程的问题。为了更简洁地表达算法的本质，常常忽略数据抽象、模块性和错误处理的问题

对于插入排序，我们将其伪代码过程命名为INSERTION-SORT，其中的参数是一个数组A[1..n]，包含长度为n的要排序的一个序列，我们使用A.length表示A中的元素的数目n。


```plaintext line-numbers

INSERTION-SORT(A)
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1
    A[i + 1] = key
```

我们开始分析，首先从一个for循环开始，for循环将运行从第二个元素一直到A的最后一个元素次，首先要做的是就是将key  = A[j]插入到表中，接着，令i =j-1，我们首先检测与j相邻的元素是否比j处的元素大，那么如果是,满足i > 0和A[i] > key，则我们让A[i]覆盖key的位置，接着i = i-1，A[i+1] = A[i]= key完成换位，由于i = i-1，现在由于key也换位完，原来的位置是j，换位完的位置是j-1，所以当前比较的元素其实是j-2。以此类推直到i = 1.

我们以集合A = (5,2,4,6,1,3)做示例

```
首先
A[j] = A[2] = 2，现在i = j-1 = 1,A[1] = 5，由于 A[1] > key。覆盖A[2] = A[1] = 5，变为

5 5 4 6 1 3

i = i-1 = 0, A[0] = 5, A[0] > key = 2,覆盖A[1] = A[0] = 5,变为

2 5 4 6 1 3

接着,j = 3，那么首先用5和4 做比较，满足条件，数组变为

2 5 5 6 1 3
i = i-1 = 1
A[i+1] = key则数组位
2 4 5 6 1 3
接着，i是大于0的，但此时2 < 4不满足A[i] > key，条件停止，j = 3 的时候返回数组

2 4 5 6 1 3

以此类推，j = 4的数组如下操作

2 4 5 6 1 3

j = 5则

2 4 5 1 6 3
2 4 1 5 6 3
2 1 4 5 6 3
1 2 4 5 6 3

j = 6则

1 2 4 5 6 3
```

实际代码，我将用C语言编写

```C
void Insert_Sort(int arr[],int len)
{
    int i,j,key;
    for(j = 1; j <len;j++)
    {   
        i = j-1;
        key = arr[j];
        while(i >= 0 && arr[i] > key)
        {
            arr[i+1] = arr[i];
            i = i-1;
             
        }
        arr[i+1] = key;  
    }
    for(int k = 0; k < len;k++)
    {
        printf("%d ",arr[k]);   
    }
}

int main()
{
    int A[] = {3,1,5,6,1,2,23};
    int len = sizeof(A) / sizeof(A[0]);
    Insert_Sort(A,len);

    return 0;
}
```

循环不变式主要用来帮助我们理解算法的正确性。而循环不变式（Loop Invariant）是在循环执行过程中始终保持为真的逻辑断言（条件 / 性质） —— 它在循环开始前成立、循环每次迭代中保持成立，最终在循环结束时，能帮助我们证明循环的正确性（比如 “循环是否完成了预期任务”“结果是否符合要求”，关于不变式，我们需要证明三条性质：

+ 初始化：循环的第一次迭代之前，它为真。
+ 保持：如果循环的某次迭代之前它为真，那么在下一次迭代之前，它仍然为真。
+ 终止：一旦循环终止，那么不变式为我们提供了一个有用的性质，该性质有助于证明算法是正确的。

简单来说，循环不变式就是数学归纳法上的归纳假设。

我们来看看对于插入排序，我们如何证明这些性质成立

**初始化：** 首先，第一次循环之前的时候(j=2)，循环不变式是成立的，此时子数组A[1,...,j-1]是单个元素A[1]，所以这算是一个平凡的结果，在第一次循环之前的循环不变式是成立的。

**保持：** 现在我们处理第二条性质，我们证明每次迭代保持循环不变式。不正式的讲，for循环体的第4~7行将A[j-1],A[j-2],A[j-3]等向右移动一个位置，直到找到A[j]的适当位置，伪代码的第8行将A[j]插入该位置，此时的子数组还是由A[1,..j-1]的元素组成，但已按照顺序排列，此时对for循环的下次迭代保持循环不变式

**终止：** 最后我们研究循环终止时发生了什么。终止条件是j > A.length = n，因为每次循环迭代j增加1，那么必然有j = n+1。由保持条件，现在A[1,..n]是已排序的，因此算法正确

### 伪代码的一些约定

+ 缩进表示块结构，例如2行开始的for循环体由2~8行组成，但第5行开始的while循环不包括第8行，它只包含6~7行。我们的缩进风格也适用于if-else语句，采用缩进代替常规的块结构标志，比如begin和end语句，可以大大提高代码的清晰性
+ while、for、repeat-until等循环结构以及if-else等条件语句与C++、C、java和pascal中的结构具有类似的解释，因此，紧接在一个for循环后，循环计数器的值就是第一个超出for循环界限的那个值，在证明插入排序的正确性时，我们使用了这个性质。档一个for循环迭代增加其循环计数器时，我们使用关键词to，若是迭代递减，我们使用关键词downto，当循环计数器以大于1的量改变时，我们可以选择性的在语句后面使用by加上该改变量

+ '//'符号表示后面部分是注释
+ 形如i = j = e的多重赋值将表达式e的值赋给i和j。等价处理成i = e 和j = e。
+ 变量是局部于给定过程的，没有说明的情况下我们不用全局变量
+ 数据元素通过数组名[下标]的方式访问。例如A[i]表示A数组的第i个元素。记号..表示数组中值的一个范围,A[1..j]表示A中从1到j的一个子数组
+ 复合数据通常被组织成对象，对象由属性组成。我们使用许多面向对象变成语言中创建的语法来访问特定的属性，例如数组就可以看作是一个对象，属性length表示数组里面由多少个元素

同时，我们把表示一个数组或对象的变量看作是指向表示数组或对象的数据的一个指针。对于对象x的所有属性f，赋值y = x导致 y.f = x.f，进一步说，若x.f =3，则赋值后不仅x.f = 3，y.f = 3。换句话说，在赋值y =x之后，x和y指向同一个对象。

属性记号是可以被串联的，假设f是一个指向某种类型具有属性g的对象的一个指针，那么记号x.f.g可以被记为(x.f).g，换句话说，若y = x.f，那么x.f.g = y.g

如果对象根本不指向任何对象，我们给他赋值特殊值NIL。

+ return语句立即将控制返回到调用过程的调用点。与一般return语句不同的是，我们的return可以返回多个值而不是单一值。
+ 布尔运算符and和or都是短路的，意思是当求表达式 x and y 时，首先求的是x，若x为False，那么表达式不可能求值为True，则我们不求y的值。同理，当求表达式x or y时，若x为True，那么表达式不可能求值为False，则我们不求y的值。
+ 关键字error表示因为调用过程情况不对而出现了一个错误。调用过程负责处理该错误。那么我们不用说明将采取说明行动

## 习题

随便做两道题

---
**输入**： n个数的一个序列$A = (a_1,\cdots,a_n)$和一个值v。
**输出**：下标i使得v=A[i]或者当v不在A 中出现时， v为特殊值NIL。写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。

---


解：

```plaintext line-numbers
Find_v(A)
for i = 1 to A.length
    if A[i] == v
        return i
return NIL
```


## 分析算法

首先，一个算法在特定输入上的 **运行时间**是指执行的基本操作数或步数。

我们首先给出插入排序中，每条语句的执行时间和执行次数，对于j = 2,3,...,n，其中n = A.length，假设t_j表示对应值j第5行执行while测试的次数，当一个for或while循环按通常的方式退出时，执行测试的次数比执行循环体的次数多1，我们假定注释是不执行的语句，所以他们不算在内。

| 伪代码行 | 代码内容 | 代价 | 次数 |
|----------|----------|------|------|
| 1 | `for j = 2 to A.length` | $c_1$ | $n$ |
| 2 | `key = A[j]` | $c_2$ | $n-1$ |
| 3 | `// Insert A[j] into the sorted sequence A[1..j-1].` | $0$ | $n-1$ |
| 4 | `i = j - 1` | $c_4$ | $n-1$ |
| 5 | `while i > 0 and A[i] > key` | $c_5$ | $\sum_{j=2}^n t_j$ |
| 6 | `A[i+1] = A[i]` | $c_6$ | $\sum_{j=2}^n (t_j - 1)$ |
| 7 | `i = i - 1` | $c_7$ | $\sum_{j=2}^n (t_j - 1)$ |
| 8 | `A[i+1] = key` | $c_8$ | $n-1$ |


该算法的运行时间是执行每条语句的运行时间之和，需要执行$c_i$步并且执行n次的一条语句贡献$c_in$给总运行时间，那么我们计算具有n个值的输入上插入排序的运行时间T[n]，就是将代价和次数列对应的元素求和，得到

$$
T(n) = c_1n+c_2(n-1)+c_4(n-1)+c_5\sum_{j=2}^n t_j+c_6\sum_{j=2}^n (t_j - 1)+c_7\sum_{j=2}^n (t_j - 1)+c_8(n-1)
$$


即使对给定规模的输入，一个算法的运行时间也可能依赖于给定的是该规模下是说明输入，假设在插入排序中，我们给定的输入数组是排好序的，则直接出现最佳情况，这是对每个j = 2,3,$\cdots$,n，都存在$t_j$ = 1，因为此时对每个A[i] $\leq $ key，所以每次都只执行一次。 那么最佳的运行情况是

$$
\begin{aligned}
T(n)  =&c_1n+c_2(n-1)+c_4(n-1)+c_5n+c_6(n-1)+c_7(n-1)+c_8(n-1)\\ =& (c_1+c_2+c_r+C_5+c_8)n - (c_2+c_4+c_5+c_8)
\end{aligned}
$$

我们可以把该运行时间表示为an+b，其中常量a和b依赖于代价$c_i$,因此它是n的线性函数

若输入数组是反向排序的，那么将导致得到最坏的情况，我们必须把每个元素A[j]与整个已排序的子数组A[1..j-1]中的每个元素做比较，所以对$j = 2,3,\cdots,n$，有$t_j = j$。那么

$$
\sum^n_{j = 2}j =  \frac{n(n+1)}{2} - 1
$$

和

$$
\sum^n_{j = 2}(j-1) =  \frac{n(n-1)}{2} - 1
$$

那么最坏情况下，插入排序的运行时间为

$$
\begin{aligned}
    T(n) =& c_1n+c_2(n-1)+c_4(n-1)+c_5(\frac{n(n+1)}{2} - 1)\\
    +&c_6(\frac{n(n-1)}{2} - 1)+c_7(\frac{n(n-1)}{2} - 1)+c_8(n-1)\\
    =& \left(\frac{c_5}{2} +\frac{c_6}{2} + \frac{c_7}{2} \right)n^2 + (c_1+c_2+c_4+\frac{c_5}{2} - \frac{c_6}{2} \\-& \frac{c_7}{2}+c_8)n - (c_2+c_4+c_5+c_8)
\end{aligned}
$$

我们可以简化最坏情况为$an^2+bn+c$，其中$a,b,c$是依赖于$c_i$的常量。因此，最坏情况下的运行时间是一个二次函数

最后我们分析平均情况和最坏的情况

在之后的章节里，我们主要研究的是最坏情况运行时间，即对规模为n的任何输入，算法的最长运行时间。下面给出这样做的三点理由

+ 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。直到了整个界，就能确保算法绝不需要更长的运行时间。我们不必对运行时间做某种复杂的猜测期望它不会变的更坏
+ 对某些算法，最坏情况经常出现，比如在数据库检索一条特定信息，若该信息不在数据库中出现，则检索算法的最坏情况将持续出现。对某些应用中，对缺失信息的检索可能是频繁的
+ 平均情况往往与最坏情况大致一样差，我们假定随机选择n个数并应用插入排序。平均来说，假设A[1..j-1]中一半元素小于A[j]，一半元素大于A[j]，那么t_j = j/2，所以平均情况也是一个二次函数，这和最坏情况大差不差。

### 增长量级

一般来说，我们经常忽略常数项，就拿插入排序来说，它的最坏平均时间是$an^2+bn+c$，其中$a,b,c$是常量。我们不关心常数项，因为当n增大时，它们相对于n的量级是微不足道的。我们只关心n的量级，即n的指数。因此，我们说插入排序的最坏情况运行时间是一个二次函数，或者说是O(n^2)的。这是来自高数的符号，大O表示函数最大不超过n^2。还有一个符号，$\Theta(n^2)$符号表示一个算法的确界。换成数学描述就是

$$
\begin{array}{cc}
    \Theta(n^2) \equiv& c_2 \cdot n^2\leq f(x) \leq c_1\cdot n^2\\
    O(n^2) \equiv& c_2 \cdot n^2\leq f(x)
\end{array}
$$

我们不关心常数项还有一个其他的原因，就是当n非常大的时候，常数项对它的影响微乎其微，注意到对$T(f) = an+b$和$T(g) = an^2+bn+c$有

$$
\lim_{n\to\infty} \frac{T(f)}{T(g)} = \lim_{n\to\infty} \frac{an+b}{an^2+bn+c} = 0
$$

因此，当n足够大时，$T(f)$相对于$T(g)$是微不足道的。

# 算法设计

我们可以选择的算法设计技术有很多，插入排序使用了增量方法，即在排序子数组A[1..j-1]后，将单个元素A[j]插入子数组的合适位置。产生排序好的子数组A[1..j]。

接下来我们考察另一个叫“分治法”的算法设计。我们使用分治法设计一个排序算法，该算法的最坏运行情况比插入排序要少得多。优点之一是，它可以很容易的确定运行时间

## 分治法

许多有用的算法结构上是递归的，为了解决一个给定的问题，算法一次或多次的递归调用自身以解决紧密相关的若干子问题，这些算法典型的遵循分治法的思想，将原问题分解为几个规模较小但类似原问题的子问题，递归的求解这些子问题任何再合并成这些子问题的解来建立原问题的解

分治模式在每层递归时有三个步骤

+ **分解**原问题为若干子问题，这些原问题是原问题规模较小的实例
+ **解决**这些子问题，若规模够小，则直接求解
+ **分解：**分解待排序的n个元素的序列成个具n/2个元素的两个子序列
+ **解决：**使用归并排序递归的排序两个子序列
+ **合并：**合并两个已排序的子序列产生已排序的答案

当待排序的序列长度为1则递归开始回升，这种情况下不需要做工作，因为长度为1的序列都是排序好的。

接下来我们做合并步骤，通过调用一个叫```MERGE(A,p,q,r)```的程序来完成合并，其中A是数组，p、q、r是数组下标，满足p $\leq $q $\leq$ r，并且该过程假设子数组A[p..q]和A[q+1..r]都已排序。该过程将它们合并成一个已排序的子数组A[p..r]。

MERGE过程大概需要$\Theta$(n)的时间，其中$n = r-q + q-p+1 = r-p+1$。

我们使用一个扑克牌的例子，假设桌子上有两堆牌面朝上的牌，每堆都是排序好的，最小的牌在顶上，我们希望把这两堆牌合成单一的排序好的堆，牌面朝下地放在桌上。我们的基本步骤就是从牌堆上挑出两张牌选取最小的一张，将该牌从其牌堆中移开。并牌面向下的放在输出堆中。重复这个步骤直到输入堆为空，由于我们只是比较牌堆上的两张，所以它的时间基本上是常量时间，而问题至多被分解为n次，因此最坏的时间也只是$\Theta$(n)。

下面给出的伪代码将实现上面的想法

但有一点不足，以避免每个基本步骤必须检查是否有堆为空，我们在每个堆的地步放一张哨兵牌，它包含特殊的值，用于简化代码，这里的哨兵牌是一张值为$\infty$的牌。它不可能是较小的牌，除非两个堆都显露出哨兵牌。但是一旦发生这种情况，说明说有非哨兵牌已经放到输出堆。因为我们知道有r-p+1张牌被放到了输出堆，所以一旦执行r-p+1个基本步骤，算法就可以被停止


```plaintext line-numbers
MERGE(A,p,q,r)
n1 = q-p+1
n2 = r-q
定义L[1..n1+1]和R[1..n2+1]是新的数组
for i = 1 to n1
    L[i] = A[p + i - 1]
for j = 1 to n2
    R[j] = A[q + j]
L[n1+1] = ∞
R[n2+1] = ∞
i = 1
j = 1
for k = p to r
    if L[i] <= R[j]
        A[k] = L[i]
        i = i + 1
    else
        A[k] = R[j]
        j = j + 1
```


它的工作模式如下：

第一行计算子数组A[p..q]的长度n1，第二行计算子数组A[q+1..r]的长度n2。第4行我们定义两个新数组L[1..n1+1]和R[1..n2+1]。每个数组中将额外的位置保存哨兵，第5-6行的for循环将子数组A[p..q]复制到L[1..n1]，第7-8行则复制到R[1..n2]。之后我们把哨兵放入数组。最后13到19行通过维持循环不变式执行r-p+1个基本步骤。

可以发现该程序是$\Theta$(n)的，注意到它的时间其实是$T(n) = n1+n2 + r-p+1 = 2n = \Theta(n)$的时间。因为大的开销只有3个for循环。前两个是创建数组，最后一个是做比较

现在我们就可以把merge作为排序中的子程序调用了。我们将嗲用merge-sort(A,p,r)来排序子数组A[p..r]的元素，若p$\geq $r，则子数组最多有一个元素，所以是排序好的，否则分解步骤将简单的计算一个下标q，将A[p..r]分解为两个子数组 A[p..q]和A[q+1..r]。前者包含$\lfloor n/r\rfloor$后者包含$\lfloor n/2\rfloor$个元素

```plaintext line-numbers
MERGE-SORT(A,p,r)
if p < r
    q = [(p+r)/2]向下取整
    MERGE-SORT(A,p,q)
    MERGE-SORT(A,q+1,r)
    MERGE(A,p,q,r)
```

为了排序整个序列，A = (A[1],A[2],...,A[n])，我们初始执行时调用MERGE-SORT(A,1,A.length)，其中A.length = n。但在代码中有些许不同，因为是从0开始的，这迫使每个索引都强制-1。

使用测试集A = {5,2,4,7,1,3,2,6}来做说明，它的归并顺序如下

```

[1,2,2,3,4,5,6,7] ⬅最终结果

[2,4,5,7], [1,2,3,6]↑归并

[2,5],[4,7],[1,3],[2,6]↑归并
 
[5],[2],[4],[7],[1],[3],[2],[6] ↑归并
```

C代码：

```c
void merge(int arr[],int p,int q, int r)
{
    //注意，必须满足条件 p <= q < r
    int n1 = q - p + 1,i,j;
    int n2 = r - q;
    int L[n1+1],R[n2+1];
    for(i = 0; i < n1 ;i++)
    {
        L[i] = arr[p+i];
    }
    for(j = 0; j < n2; j++)
    {
        R[j] = arr[q+j+1];
    }
    //由于实际编程不存在无穷大，我们用Limit提供的定义来替代
    L[n1] = INT_MAX;
    R[n2] = INT_MAX;
    i = 0;
    j = 0;
    for(int k= p; k < r ; k++)
    {
        if(L[i] <= R[j])
        {
            arr[k] = L[i];
            i = i+1;
        }
        else
        {
            arr[k] = R[j];
            j = j+1;
        }
    }

}

void merge_sort(int arr[],int p,int r)
{
    if(p < r)
    {
        int q = floor((p+r)/2);
        merge_sort(arr,p,q); //q前面的子数组
        merge_sort(arr,q+1,r); //q到r的子数组
        merge(arr,p,q,r);
    }
}

int main()
{
    int A[] = {5,2,4,7,1,3,2,6};
    int Alen = sizeof(A) / sizeof(A[0]);
    merge_sort(A,0,Alen-1);//归并排序
    for(int i = 0; i < Alen; i++)
    {
        printf("%d ",A[i]);
    }
    return 0;
}

```


## 分治算法分析

当一个算法包含对其自身的递归调用时，我们往往可以用递归方程或递归式来描述其运行时间。我们假定分析的是规模为n的一个问题的运行时间。如果问题规模足够小，比如对某个常量c，n $\leq $ c，则直接求解需要常量时间，我们将其写为$\Theta$(1)的。假设把每个问题分解为a个子问题，每个子问题的规模都是原问题的1/b。为了求解一个规模为a/b的子问题，需要T(n/b)的时间，所以需要aT(n/b)的时间求解a个子问题，如果分解问题或子问题需要D(n)的时间，合并需要C(n)，那么得到递推式

$$
T(n) = \begin{cases}
    \Theta(1)  & 若 n\leq c\\
    aT(n/b) + D(n) + C(n) 其他
\end{cases}
$$

### 归并算法的分析

前面已经给出了一般分治算法的递推式。对于分解步骤，实际上就是计算子数组的中间位置，该步骤的时间复杂度是常量时间，D(n) = $\Theta$(1)，解决步骤下，我们递归的求解两个规模为$n/2$的子问题，那么将贡献2T(n/2)的运行时间，另外，对于合并步骤，我们已经知道在一个具有n个元素的子数组上运行Merge需要$\Theta$(n)的时间，所以C(n) = $\Theta$(n)。因此，归并排序的递推式为

$$
T(n) = \begin{cases}
    \Theta(1)  & 若 n\leq c\\
    2T(n/2) + \Theta(n) &其他
\end{cases}
$$

实际上很容易看出来T(n) 实际上是$\Theta(n\lg n)$，书上需要用主定理证明，但其实不需要，注意到每一层都是前面规模的1/2，那么一层元素是n/2^k，分了 lg(n)层，最坏情况下一层也就指向n次，所以是nlg(n)的时间

### 习题

---

我们使用数学归纳法证明，当n是2的幂次时，下述递推式的解是$T(n) = \Theta(n\lg n)$，注意$\lg n = \log_2 n$

$$
T(n) = \begin{cases}
    2  & 若 n= 2\\
    2T(n/2) + n & 若n = 2^k , k> 1
\end{cases}
$$

---

**证明：** 对基础步骤，注意到 n= 2^1时，T(n) = $2\lg 2 = 2 \cdot 1 =2 $成立，对于归纳步骤，我们假设对$m \in \mathbb{Z}$都有即$n = 2^m$递归式满足$T(n) = n\lg n$。令$k = m+1$，$n = 2^{m+1}$，那么

$$
\begin{array}{lll}
    T(2^{m+1}) &=& 2T(2^m)+2^{m+1}\\
               &=& 2 \cdot 2^m\lg 2^m + 2^{m+1}\\
               &=& 2^{m+1} \cdot m + 2^{m+1}\\
               &=& 2^{m+1} \cdot (m+1)\\
               &=& 2^{m+1} \lg 2^{m+1}\\
               &=& n\lg n
\end{array}
$$

Q.E.D
