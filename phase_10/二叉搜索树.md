# 二叉搜索树

## 前言

二叉搜索树基本操作和树的高度成正比。若一颗完全二叉树具有$n$个节点，这些操作的最坏运行时间为$\Theta(\lg n)$。若这颗树是$n$个节点组成的线性链，那么同样的操作需要$\Theta(n)$

## 什么是二叉搜索树

**定义（二叉搜索树）：** 一棵二叉搜索树以一课二叉树定义，它可以使用链表数据结构表示，每个节点都是一个对象，除了key和卫星数据之外，每个节点还包含属性```left right```和```p```，分别表示左孩子，右孩子和双亲，若某个孩子节点不存在或父节点不存在，则对应属性为```Null```。根节点是树中唯一父指针为```Null```的节点。

**性质1：** 设$x$是二叉搜索树中的一个节点，若$y$是$x$左子树中的一个节点，则```y.key <= x.key```，若$y$是$x$右子树中节点，则```y.key >= x.key```

二叉搜索树必须满足上述的性质，这是保证复杂度在$O(\lg n)$的前提。

基于此性质，我们可以通过一个简单的递归算法按序输出二叉搜索树中的所有关键字，这种算法称为中序遍历(inorder tree wale)算法。还有其他两种算法，分别是先序和后序遍历

我们通过调用下面的```INORDER-TREE-WALE(T.root)```函数实现。

```
INORDER-TREE-WALE(x)
    if x != NULL
    INORDER-TREE-WALK(x.left)
    print x.key
    INORDER-TREE-WALK(x.right)
```
C代码：


基础数据结构：
```C

typedef struct BSTree
{
    int data;
    int key;
    struct  BSTree* left;
    struct BSTree* right;
}bst;

bst* create_bstree(int data,int key)
{
    bst* newNode = (bst*)malloc(sizeof(bst));
    if(newNode == NULL)
    {
        printf("create node fail/r/n");
        return 0;
    }
    newNode->key = key;
    newNode->data = data;
    newNode->left = NULL;
    newNode->right= NULL;
}
```

主要函数：
```C
void INORDER_TREE_WALK(bst* T)
{
    if(T == NULL)
    {
        return;
    }
    INORDER_TREE_WALK(T->left);
    printf("%d ",T->key);
    INORDER_TREE_WALK(T->right);
}

```


**定理：** 若$x$是一棵有$n$个节点子树的根，那么调用```INORDER-TREE-WALK(x)```函数需要$O(n)$时间
 
**证明：** 当该函数作用于一棵具有$n$个节点子树的根时，我们用$T(n)$表示需要的时间，由于该过程访问树上全部的$n$个节点，因此$T(n) = \Omega(n)$，下证$T(n) = P(n)$

给定二叉树$B$，若$B$是空树，则花费常数时间。对某个常数$c > 0$，$T(0) = 0$

若$n > 0$，将过程作用在$B$的一个节点$x$上，假设$x$的左子树具有$k$个节点，右子树存在$n-k-1$个节点，则执行```INORDER-TREE-WALK(x)```的时间为$T(k) + T(n-k-1) + d$。其中常数$d >0 $。现在，我们拆开递推式，合并每一层的合并开销为数$d$，在最后一层，花费的时间是常数$c$，因此，$T(k) = (c+d)*k + c$，归纳的有，对$n > 0$

$$
\begin{array}{lll}
    T(n) &\leq& T(k) + T(n-k-1) + d \\
    &=& (c+d)*k + c + (c+d)*(n-k-1) + d \\
    &=& c*n + d*(n-1) = O(n)
\end{array}
$$

证毕


## 查询二叉树

我们使用下述的过程在一棵二叉搜索树中寻找一个具有给定关键字的节点，输入一个指向树根的指针和一个关键字k，若节点存在，```Tree-Search```返回一个指向关键字为k的节点的指针，否则返回NULL

```
TREE-SEARCH(T,k)
    if T == NULL or k == T.key
        return T
    if k < T.key
        return TREE-SEARCH(T.left,k)
    else
        return TREE-SEARCH(T.right,k)
```

```C
bst* Tree_Search(bst* x,int k)
{
    if(x == NULL && k == x->key)
    {
        return x;
    }
    if(k < x->key)
    {
        return Tree_Search(x->left,k);
    }
    else
    {
        return Tree_Search(x->right,k);
    }
}
```

由完全二叉树的性质，该程序首先在根节点开始寻找，若k小于根节点的key值，那么转而向左子树寻找节点，否则向右子树寻找。如果两个关键字相等，查找终止。我们可以很容易的得到这个程序的运行时间为$O(h)$，$h$是树的高度。注意一般情况下每个节点都是常数时间的，一共运行$h$次，所以查找时间是$O(h)$

使用while循环来展开递归，用迭代的形式重写这个方程将高效很多

```
while( x != NULL && k != x.key)
    if k < x.key
        x = x.left
    else 
        x = x.right
    return x
```

从树根开始沿着左孩子指针直到遇到一个NULL，我们总能在一棵二叉树中找到一个元素，该元素总是小于其他关键字的，下面的程序返回一个指向给定节点x为根的子树中的最小元素指针

```
Tree-min(x)
while x.left != NULL
    x = x.left
return x
```

```C
bst* Tree_min(bst* x)
{
    while(x->left != NULL)
    {
        x = x->left;
    }
    return x;
}
```
该程序返回一个指向给定节点x为根的子树中的最大元素指针

```
Tree-max(x)
while x.right != NULL
    x = x.right
return x
```

```C
bst* Tree_max(bst* x)
{
    while(x->right != NULL)
    {
        x = x->right;
    }
    return x;
}
```
## 插入和删除

将一个新值v插入到一棵二叉搜索树T中，需要调用过程Tree-insert，该函数用z做输入，其中z.key = v，z.left = NULL，z.right = NULL，我们可能需要修改树T和z的某些属性来使得z插入到树的相应位置上。

```
TREE-INSERT(T,z)
 
y = NULL
x = T.root 
while x != NULL
    y = x
    if z.key < x.key
        x = x.left
    else
        x = x.right
z.p = y
if y == NULL
    T.root = z
else if z.key < y.key
    y.left = z
else
    y.right = z
```

该过程分为两个步骤，首先，对整个while循环，实际上它在寻找树中关于要插入的节点x的父节点。并将结果保存在z.p属性中。其次，将z插入到树中，根据y是否为NULL，将z插入到树中，若y为NULL，表示是空树，则z成为根节点，否则，z成为y的左孩子或右孩子，取决于z.key和y.key的大小关系。

该while循环同样也是$O(h)$的。因此整个函数的复杂度就是$O(h)$

为了实现整个程序，我们需要做出树结构的一些修改，下面是修改完的结构，我们添加了一个属性p。用来记录子节点的父节点：

```C
typedef struct BSTree
{
    int data;
    int key;
    struct BSTree* p;
    struct  BSTree* left;
    struct BSTree* right;
}bst, *Tree_Root;
```

```C
void Tree_insert(Tree_Root *T,bst* z) //T为头节点，使用二级指针方便修改
{
    bst *y = NULL; //记录头节点
    bst *x = *T; 

    while( x != NULL)
    {
        y = x;
        if(z->key < x->key)
        {
            x = x->left;
        }
        else
        {
            x = x->right;
        }
    }
    z->p = y; //这行十分重要
    if(y == NULL)
    {
        *T = z;
    }
    else if(z->key < y->key)
    {
        y->left = z;
    }
    else
    {
        y->right = z;
    }
}

```

若对于删除操作，则有如下三种基本情况

给定一个待删除节点z，删除它具有如下三种情况：

+ 若z无子节点，则直接将其删除即可，并修改父节点的指针，将子节点改为NULL
+ 若z只有一个子节点，将其提升到原来z的位置，然后修改z的父节点，用z的孩子替换z
+ 若z有两个子节点，我们寻找z的后继y，它是这样的元素，即z的后继y是在所有大于z.key的元素中最小的一个。接着，我们将z的右子树变成y的新右子树，z的左子树变成y新的左子树。

首先，为了在树中移动子树，我们给定一个子过程TRANSPLANT，它使用另一棵子树替换一棵子树并成为其双亲的孩子节点。

```
TRANSPLANT(T,u,v)
{
    if u.p == NULL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else
        u.p.right = v
    if v != NULL
        v.p = u.p
}
```

首先，若u的父节点是空的，说明u是根节点，替换u相当于是直接把整个树的根节点替换为v。其次，若u是u的父节点的左孩子，则替换其的左孩子，右孩子同样这么做。接着，让v节点直接继承u的父节点即可。（这么做相当于是组成了一个双向链表）


```C
void Transplant(Tree_Root *T, bst* u, bst* v)
{
    if(u->p == NULL)
    {
        *T = v;
    }
    else if(u == u->p->left)
    {
        u->p->left = v;
    }
    else u->p->right = v;
    if(v != NULL)
    {
        v->p = u->p;
    }
}
```


接着，我们来处理删除函数，首先需要一个能找到最小元素的函数，他帮助我们找到节点的后继。

```C
bst* Tree_min(bst*x)
{
    while(x->left != NULL)
    {
        x = x->left;
    }
    return x;
}
```


我们来看删除程序的伪代码

``` 
TREE-DELETE(T,z)
```
```line-numbers
    if z.left == NULL
        TRANSPLANT(T,z,z.right)
    elseif z.right == NULL
        TRANSPLANT(T,z,z.left)
    else y = TREE-MINIMUM(z.right)
        if y.p != z
            TRANSPLANT(T,y,y.right)
            y.right = z.right
            y.right.p = y
        TRANSPLANT(T,z,y)
        y.left = z.left
        y.left.p = y
```

我们来解释这个程序，跟之前说的一样，该程序处理种情况，

1-2行，处理节点z无左孩子的情况，3-4行处理z有一个左孩子但没有右孩子的情况。5~12行处理剩下的两种情况，即z存在两个孩子。这比较简单，现在我们着重分析第5行代码之后的程序，5行开始，是其他情况，我们寻找节点z的后继，并储存在y中。若y不是z的子节点，由于y是后继，所以它没有左孩子(后继是大于z中最小的子节点)，然后，第7行我们把y从它的位置拿出来，用y的右子树填上，然后，第8行，将z的右子树复制到y上，让z的右子树的父节点为y。这样就完成了替换的操作。最后，将z用已经替换完右子树的y替换，然后拼接上y的左子树即完成删除操作。

```C

void Tree_delete(Tree_Root *T,bst* z)
{
    bst *y = NULL;
    if(z->left == NULL)
    {
        Transplant(T,z,z->right);
    }
    else if(z->right == NULL)
    {
        Transplant(T,z,z->left);
    }
    else 
    {
        y = Tree_min(z->right);
        if(y->p != z)
        {
            Transplant(T,y,y->right);
            y->right = z->right;
            y->right->p = y;
        }
        Transplant(T,z,y);
        y->left = z->left;
        y->left->p = y;
    }

}
```

容易发现删除和插入操作都是$O(h)$的，$h$是树的高度。所以我们实际上就是在证明这个定理：

**定理：** 对于一棵高度为$h$的二叉树，实现动态几何操作```INSERT```和```DELETE```运算的复杂度均为$O(h)$