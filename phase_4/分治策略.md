[toc]

## 矩阵乘法的Strassen算法



定义$A = (a_{ij})$和$B = (b_{ij})$为$n\times n$的方阵。我们定义$C = A\times B$的元素为
$$
C_{ij} = \sum^n_{k = 1}a_{ik}\cdot b_{kj}
$$

那么我们通常需要计算$n^2$个矩阵元素，每个元素都是$n$个值的和，下面过程接收$n\times n$矩阵$A$和$B$，返回它们的乘积$C$，给定矩阵都有一个属性rows，即矩阵的行数

``` line-numbers
SQUARE_MATRIX_MULTIPLY(A, B)

n  = A.rows
define C is n x n martix
for i  = 1 to n
    for j = 1 to n
        c_ij = 0
        for k = 1 to n
            c_ij = c_ij+a_ik*b_kj
return C
```
C代码是这样的：

```c
int rows = 3;

void square_matrix_multply(int A[rows][rows], int B[rows][rows],int C[rows][rows],int M_rows)
{
    int n = M_rows;
    for(int i = 0; i < n ; i++)
    {
        for(int j = 0; j < n; j++)
        {
            C[i][j]  = 0;
            for (int k = 0; k< n;k++)
            {
                C[i][j] = C[i][j] + A[i][k]*B[k][j];
            }
        }
    }
    return
    ;
}

int main()
{
    int A[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
    int B[3][3] = {{11,12,13},{14,15,16},{17,18,19}};
    int C[3][3];
    square_matrix_multply(A,B,C,rows);
    for(int i = 0; i< rows;i++)
    {
        for(int j = 0; j < rows; j++)
        {
            printf("%d ",C[i][j]);
        }
        printf("\r\n");
    }
    return 0;
}
```

这是一个花费$\Theta$($n^3$)的代码

接下来的Strassen算法大概时间在$\Theta(n^{\lg 7}) \approx O(n^{2.81})$。

### 简单的分治算法

当我们计算矩阵乘积$C = A\cdot B$时，假定三个矩阵都是$n\times n$矩阵，其中$n$是$2$的幂次。假设这样是因为好计算，$n\times n$矩阵都被划分为4个$n/2 \times n/2$的子矩阵。那么有如下分解

$$
A = \begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix}, \quad
B = \begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22}
\end{bmatrix}, \quad
C = \begin{bmatrix}
C_{11} & C_{12} \\
C_{21} & C_{22}
\end{bmatrix}
$$

因此我们把公式$C = A\cdot B$改写为

$$
\begin{bmatrix}
C_{11} & C_{12} \\
C_{21} & C_{22}
\end{bmatrix}=
\begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix}
\cdot
\begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22}
\end{bmatrix}
$$

那么上述公式应该等价于下述的公式

$$
\begin{aligned}
C_{11} &= A_{11}B_{11} + A_{12}B_{21} \\
C_{12} &= A_{11}B_{12} + A_{12}B_{22} \\
C_{21} &= A_{21}B_{11} + A_{22}B_{21} \\
C_{22} &= A_{21}B_{12} + A_{22}B_{22}
\end{aligned}
$$

每个公式又对于两对$n/2 \times n/2$矩阵的乘法及$n/2\times n/2$积的加法，那么我们以此为基础设计一个直接的递归分治算法：

```line-numbers
square-matrix-multiply-recursive(A,B)
n = A.rows
Let C be a new nxn martix
if n == 1
    c_11 = a_11 * b_11
else
    将A,B,C划分为4个矩阵
    C_11 = square-matrix-multiply-recursive(A_11,B_11)
    C_12 = square-matrix-multiply-recursive(A_11,B_12)
    C_21 = square-matrix-multiply-recursive(A_21,B_11)
    C_22 = square-matrix-multiply-recursive(A_21,B_22)
return C
```

C代码实现
```c line-numbers
void square_matrix_multiply_recursive(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE],
                                      int a_row, int a_col, int b_row, int b_col, int c_row, int c_col, int n) {
    if (n == 1) {
        // 单个元素相乘
        C[c_row][c_col] += A[a_row][a_col] * B[b_row][b_col];
        return;
    }

    int half = n / 2;

    // C11 = A11*B11 + A12*B21
    square_matrix_multiply_recursive(A, B, C, a_row, a_col, b_row, b_col, c_row, c_col, half);
    square_matrix_multiply_recursive(A, B, C, a_row, a_col+half, b_row+half, b_col, c_row, c_col, half);

    // C12 = A11*B12 + A12*B22
    square_matrix_multiply_recursive(A, B, C, a_row, a_col, b_row, b_col+half, c_row, c_col+half, half);
    square_matrix_multiply_recursive(A, B, C, a_row, a_col+half, b_row+half, b_col+half, c_row, c_col+half, half);

    // C21 = A21*B11 + A22*B21
    square_matrix_multiply_recursive(A, B, C, a_row+half, a_col, b_row, b_col, c_row+half, c_col, half);
    square_matrix_multiply_recursive(A, B, C, a_row+half, a_col+half, b_row+half, b_col, c_row+half, c_col, half);

    // C22 = A21*B12 + A22*B22
    square_matrix_multiply_recursive(A, B, C, a_row+half, a_col, b_row, b_col+half, c_row+half, c_col+half, half);
    square_matrix_multiply_recursive(A, B, C, a_row+half, a_col+half, b_row+half, b_col+half, c_row+half, c_col+half, half);
}

```
我们来简单的解释一下这份代码，函数square_matrix_multiply_recursive(A,B,C,a_row,a_col,b_row,b_col,c_row,c_col,n)接收6个参数，分别是输入A,B矩阵，输出C矩阵，以及最重要的是，他们的下标a_row,a_col,b_row,b_cols了，还有c_row,c_col。以及用于定义矩阵大小的size。

首先先掠过n==1的情况，我们来看如下的递归树

给定两个矩阵
矩阵 A：
\[
A = \begin{pmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{pmatrix}
\]

矩阵 B：
\[
B = \begin{pmatrix}
b_{11} & b_{12} & b_{13} & b_{14} \\
b_{21} & b_{22} & b_{23} & b_{24} \\
b_{31} & b_{32} & b_{33} & b_{34} \\
b_{41} & b_{42} & b_{43} & b_{44} \\
\end{pmatrix}
\]

```
layer 1: 
    A: [A11 A12] A11 = [a11 a12] A12 = [a13 a14]
       [A21,A22]       [a21 a22]       [a23 a24]

                 A21 = [a31 a32] A22 = [a33 a34]
                       [a41 a42]       [a43 a44]

    B: [B11 B12] B11 = [b11 b12] B12 = [b13 b14]
       [B21 B22]       [b21 b22]       [b23 b24]

                 B21 = [b31 a32] B22 = [b33 b34]
                       [b41 a42]       [b43 b44]   
layer 2:  //layer2基本上就是单个元素了
    A11 : [a11] [a12]  A12 : [a13] [a14]
          [a21] [a22]        [a23] [a24]

    A21 : [a31] [a32]  A22 : [a33] [a34]
          [a41] [a42]        [a43] [a44]

    B11 : [b11] [b12]  B12 : [b13] [b14]
          [b21] [b22]        [b23] [b24]

    B21 : [b31] [b32]  B22 : [b33] [b34]
          [b41] [b42]        [b43] [b44]
```
递归将在layer2停止，接着我们回到 ```n==1```的情况，$c_{11}$对应的是$(a_{11},a_{12},a_{13},a_{14}) \cdot (b_{11},b_{21},b_{31},b_{41})$，看layer2，我们对号入座，对代码的12行，C11首先选择A11的第一个和B11的第一个元素。然后13行，选择A12和B21。这完全对的上，以此类推，直到我们遍历8个矩阵。就是表现出点乘的形式了。
