# 快排的随机化版本

在讨论快排的时候，我们的前提假设是输入数据的所有排列都是等概率的，实际情况中很少实现，因此我们引入随机性来补正算法。使得我们可以获得较好的期望性能。

我们采用一种称为随机抽样的随机化技术，随机抽样是从子数组```A[p..r]```中随机选择一个元素作为主元。为了得到该方法，我们首先将```A[r]```和```A[p..r]```中随机选出的一个元素交换。通过对p..r的随机抽样，我们可以保证主元元素x = A[r]是等概率的从r-p+1个元素的子数组中抽取，因为主元素是随机抽取。

对PARTITION和QUICKSORT的代码改动非常小，伪代码如下：

```C
RANDOMIZED-PARTITION(A,p,r)
1| i = RANDOM(p,r)
2| 交换 A[r]和A[i]
3| return PARTITION(A,p,r)
```

我们只是在划分前进行了一次随机的交换。

```C
RANDOMIZED-QUICKSORT(A,p,r)
1| if p < r
2| q = RANDOMIZED-PARTITION(A,p,r)
3| RANDOMIZED-QUICKSORT(A,p,q-1)
4| RANDOMIZED-QUICKSORT(A,q+1,r)
```

代码如下：


```C
int Partition(int arr[],int p,int r)
{
    int x = arr[r];
    int i = p - 1;
    for (int j = p; j < r; j++)
    {
        if (arr[j] <= x)
        {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[r];
    arr[r] = temp;
    return i + 1;
}

int random_partition(int arr[],int p, int r)
{
    int i = p + rand() % r;
    int temp = arr[i];
    arr[i] = arr[r];
    arr[r] = temp;
    return Partition(arr,p,r)
}

void random_quicksort(int arr[],int p,int r)
{
    if (p < r)
    {
        int q = random_partition(arr, p, r);
        random_QuickSort(arr, p, q - 1);
        random_QuickSort(arr, q + 1, r);
    }    
}
```

之后我们分析该算法。