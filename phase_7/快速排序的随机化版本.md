# 快排的随机化版本

在讨论快排的时候，我们的前提假设是输入数据的所有排列都是等概率的，实际情况中很少实现，因此我们引入随机性来补正算法。使得我们可以获得较好的期望性能。

我们采用一种称为随机抽样的随机化技术，随机抽样是从子数组```A[p..r]```中随机选择一个元素作为主元。为了得到该方法，我们首先将```A[r]```和```A[p..r]```中随机选出的一个元素交换。通过对p..r的随机抽样，我们可以保证主元元素x = A[r]是等概率的从r-p+1个元素的子数组中抽取，因为主元素是随机抽取。

对PARTITION和QUICKSORT的代码改动非常小，伪代码如下：

```C
RANDOMIZED-PARTITION(A,p,r)
1| i = RANDOM(p,r)
2| 交换 A[r]和A[i]
3| return PARTITION(A,p,r)
```

我们只是在划分前进行了一次随机的交换。

```C
RANDOMIZED-QUICKSORT(A,p,r)
1| if p < r
2| q = RANDOMIZED-PARTITION(A,p,r)
3| RANDOMIZED-QUICKSORT(A,p,q-1)
4| RANDOMIZED-QUICKSORT(A,q+1,r)
```

代码如下：


```C
int Partition(int arr[],int p,int r)
{
    int x = arr[r];
    int i = p - 1;
    for (int j = p; j < r; j++)
    {
        if (arr[j] <= x)
        {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[r];
    arr[r] = temp;
    return i + 1;
}

int random_partition(int arr[],int p, int r)
{
    int i = p + rand() % r;
    int temp = arr[i];
    arr[i] = arr[r];
    arr[r] = temp;
    return Partition(arr,p,r)
}

void random_quicksort(int arr[],int p,int r)
{
    if (p < r)
    {
        int q = random_partition(arr, p, r);
        random_QuickSort(arr, p, q - 1);
        random_QuickSort(arr, q + 1, r);
    }    
}
```

之后我们分析该算法。

## 随机版本的算法分析

首先我们分析最坏情况，对于一般快排，最坏情况在$O(n^2)$上。下面是更严格的证明，然后我们利用该证明来分析随机版的快速排序算法。

设$T(n)$是QUICKSORT在规模为n的数据集合上花费的最坏时间。那么他的递归式为

$$
T(n) = \max_{0 \leq q \leq n-1}(T(q)+T(n-q-1)) + \Theta(n)
$$

由于PARTITION函数生成的两个子问题规模总和为n-1，因此参数q在0到n-1是十分自然的，我们假设$T(n) \leq cn^2$成立。其中$c$是常数，将其带入递归式中可得

$$
\begin{array}{lll}
    T(n)& \leq& \max_{0 \leq q \leq n-1} (cq^2 + c(n-q-1)^2) + \Theta(n)\\
    &=&c \cdot \max_{0 \leq q \leq n-1} (q^2+(n-q-1)^2)+\Theta(n)
\end{array}
$$

我们对$q^2+(n-q-1)^2$求关于$q$的二阶导，二阶导为正，那么我们借此可得上界有$\max_{0\leq q\leq n-1} (q^2+(n-q-1)^2) \leq (n-1)^2 = n^2-2n+1$，就有

$$
T(n) \leq n^2-2n+1 +\Theta(n) \leq cn^2
$$

所以很简单就可以证明最坏情况就是$O(n^2)$。当然也容易证明$T(n) = \Omega(n^2)$，只需要对上述式子求极限即可。因此实际上最坏情况是$\Theta(n^2)$

### 期望运行时间

首先，对一个包含n个元素的数组上运行QUICKSORT时，若在PARTITION程序中的做比较的次数为X，那么QUICKSORT的运行时间为$O(n+X)$。X是很简单发现的，因为每次for循环上，都需要做一次比较。


计算每一个比较次数显然是不现实的，因此我们决定只找出该比较次数的一个上界。以便于我们分析，我们定义数组A的元素重命名为$z_1,z_2,\cdots,z_n$，其中$z_i$是第$i$小的元素。接着，定义A的子集$Z_{ij}$，它表示从$z_i$到$z_j$的元素的集合。

一次调用中只比较1次，因为我们一次至多比较一对，其中一个元素是主元元素。比较完之后在下一次调用之前都不会被做比较。

假设算法在任意时间发生比较操作，而不是局限在循环的一次迭代或者PARTITION的一次调用中发生。由于每一对元素至多比较一次，所以我们可以容易的得到算法的总比较次数

$$
X = \sum^{n-1}_{i= 1}\sum^n_{j = i+1}X_{ij}
$$

其中$X_{ij} = I(x_i \text{和} x_j\text{比较})$为随机变量

我们只需要两边取期望，利用期望的线性性质，可以得到
$$
E[X] = \sum^{n-1}_{i= 1}\sum^n_{j = i+1}\Pr(X_{ij})
$$

考虑快速排序的一个输入，排查两个元素何时不会被比较，假设这个输入为1到10，主元设为7，那么第一次调用将这些数字划分为两个集合$\{1,2,3,4,5,6\}$和$\{8,9,10\}$。该过程中，主元7和其他所有元素比较，但是第一个集合中的任意一个元素不会和第二个集合的元素做比较，比如2和9永远不会做比较。

我们假设每个元素的值都是互异的，因此，一旦有一个满足$z_i < x < z_j$的主元$x$被选定之后，$z_i$和$z_j$后的元素都不会被比较了。

我们计算来计算这一事件发生的概率，首先，在$Z_{ij}$中的某个元素被选为主元之前，该区间内的所有元素都等概率的可能被选为主元。由于$Z_{ij}$含有$j -i+1$个元素，并且主元的选择是随机且独立的，那么选择一个元素为主元的概率是$1/(j-i+1)$，因此

$$
\begin{array}{lll}
  \Pr(X_{ij}) =  \Pr(z_i和z_j比较) &=& \Pr(z_i或z_j是集合Z_{ij}上选中的第一个主元)\\ &=&\Pr(z_i是集合Z_{ij}选出的第一个主元)\\
  &+& \Pr(z_j是选中的第一个主元)\\
  &=& \frac{1}{j-i+1} + \frac{1}{j-i+1} = \frac{2}{j-i+1}
\end{array}
$$

加号成立的原因是两个事件独立。那么

$$
E[X] = \sum^{n-1}_{i=1}\sum^n_{j=i+1}\frac{2}{j-i+1}
$$

令$k = j-i$，那么容易计算调和级数的一个上界

$$
E[X] = \sum^{n-1}_{i=1}\sum^n_{k=1}\frac{2}{k+1} < \sum^{n-1}_{i=1}\sum^n_{k=1} \frac{2}{k} = \sum^{n-1}O(\lg n) = O(n\lg n)
$$

其中$\sum^n_{k=1}\frac{2}{k} > \int^n_{1}\frac{2}{k}dk$

因此，在输入元素互异的情况下，快速排序算法的期望运行时间在$O(n\lg n)$