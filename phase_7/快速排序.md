# 第7章-快速排序

快速排序是一种时间复杂度为$\Theta(n^2)$的排序算法，虽然最坏情况复杂度很差，但快排是实际排序应用中最好的选择，因为他的平均性能很好，期望时间复杂度是$\Theta(n\lg n)$。并且支持原址排序，甚至在虚存环境也可以很好工作。

## 快排描述

快速排序也使用了分治思想，下面是一个对典型子数组```A[p..r]``` 快速排序的三步分治过程：

首先，数组```A[p..r]```被划分为两个(可能为空)子数组```A[p..q-1]```和```A[q+1..r]```。使得 ```A[p..q-1]```中的每一个元素都小于等于```A[q]```，并且```A[q]```也小于等于```A[q+1..r]```中的每个元素，其中，计算下标```q```也是划分过程的一部分。

**解决：** 通过递归调用快速排序，对子数组```A[p..q-1]```和```A[q+1..r]```进行排序

**合并：** 因为子数组都是原址排序的，所以不需要合并操作，没有额外的空间开销，所以此时数组```A[p..r]```已经有序

下面是伪代码：

```
QUICKSORT(A, p, r)
1|  if p < r
2|     q = PARTITION(A,p,r) //q是返回前面严格排序后的数组的前一个元素地址，因为A[r]之前的元素都是严格小于A[r]的，但是没有做排序
3|     QUICKSORT(A,p,q-1)
4|     QUICKSORT(A,q+1,r)
```
为了排序一个数组```A```的全部元素，初始调用为```QUICKSORT(A,1,A.length)```。

算法的关键为```PARTITION```过程，它实现对```A[p..r]```的原址重排


```
PARTITION(A,p,r)
1|  x = A[r]
2|  i = p-1
3|  for j = p to r-1
4|      if A[j] <= x
5|          i = i+1
6|          exchange A[i] with A[j]
7|  exchange A[i+1] with A[r]
8|  return i+1
```

```PARTITION```总是选择一个```x = A[r]```作为主元，并围绕它来划分子数组```A[p..r]```。随着程序执行，数组被划分为4个区域(可能为空)。在3-6行的for循环的每一轮迭代的开始，每一个区域都满足一定的性质，我们将这些性质作为循环不变量:

1. 若 $p \leq k \leq i$，则```A[k] <= x```
2. 若$i+1 \leq k\leq j-1$，则```A[k] > x```
3. 若$k= r$，则```A[k] = x```

也就是说这个过程后的数组满足上面3条性质，它是这样排序的：

```
(a)
     |2 |8|7|1|3|5|6|4| (数组)
    i|pj|           |r| (位置)

(b) 对于过程(a), A[j] < A[r]，i = p-1 +1,p-1没有元素，因此不做任何改变，有
    |2  |8|7|1|3|5|6|4|
    |p i|j|         |r|

(c) 对过程(b)，A[j] > A[r] 跳过过程得到
    |2 |8|7|1|3|5|6|4|
    |pi|j|       |r|

(d) A[j] > A[r]，跳过
    |2 |8|7|1|3|5|6|4|
    |pi| |j|     |r|

(e) A[j] < A[r] => 1 < 4，i = i+1然后交换A[i]和A[j]

    |2|1|7|8|3|5|6|4|
    |p|i| |j|     |r|

(f) A[j] < A[r] => 3 < 4重复过程，得到

    |2|1|3|8|7|5|6|4|
    |p| |i|   |j| |r|

(g) A[j] > A[r] ，跳过
    |2|1|3|8|7|5|6|4|
    |p| |i|     |j|r|

(h) A[j] > A[r] 跳过

    |2|1|3|8|7|5|6|4  |
    |p| |i|       |j r|

(i) 现在j = r，循环结束，交换A[i+1]和A[r]，我们得到

    |2|1|3|4  |7|5|6|8|
    |p|   |i+1|   |r|
```
现在,i+1指向元素4，那么接着我们排序前面3个元素，即2,1,3，所以下一个数组带入```QUICKSORT(A,p,i)```，现在进入第二层递归，首先进入的p = 1小于i = 3，那么运行排序程序```PARTITION(A,p,i)```，由于3比前面2个元素都大，i不变，递归程序是```QUICKSORT(A,p,i-1)```，即元素2和1，运行排序程序，由于1比2小，交换位置得到```|1|2|```。返回i+1，也就是i。此时已经排序完毕，那么运行下一个层递归，即i+1到r的元素

代码：
```C
int Partition(int arr[],int p,int r)
{
    int x = arr[r];
    int i = p - 1;
    for (int j = p; j < r; j++)
    {
        if (arr[j] <= x)
        {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[r];
    arr[r] = temp;
    return i + 1;
}
void QuickSort(int arr[],int p, int r)
{
    if (p < r)
    {
        int q = Partition(arr, p, r);
        QuickSort(arr, p, q - 1);
        QuickSort(arr, q + 1, r);
    }
}

```

测试数组：```10 7 8 9 1 5```
结果：

```
Unsorted array: 
10 7 8 9 1 5
Sorted array:
1 5 7 8 9 10
```

## 快速排序的性能

排序的性能依赖于划分是否平衡，这个关键的因素取决于我们用于划分的元素，即中间点。平衡的划分使得快排性能和归并排序一样，不平衡则使得其接近插入排序。本节我们讨论平衡和不平衡时快排的性能

### 最坏情况

划分的最坏情况产生于两个子问题一个包含了n-1个元素，一个包含了0个元素的时候，我们假设每一次划分都出现这种不平衡划分，则划分操作的时间复杂度为$\Theta(n)$。对一个大小为0的数组进行递归调用导致直接返回，则$T(0) = \Theta(1)$。算法的平均时间就是

$$
T(n) = T(n-1)+T(0) +\Theta(n) = T(n-1)+\Theta(n)
$$

注意到每次递归的代价累加起来是

$$
\sum^{n}_{i = 0} \Theta(i) = \frac{n(n+1)}{2} = \Theta(n^2)
$$

因此，该时间复杂度为$\Theta(n^2)$。但在同样情况下，插入排序的时间复杂度为$O(n)$

### 最好情况分析

在最可能的情况中，划分后的两个子问题规模不大于$n/2$。因为一个子问题的规模为$\lfloor n/2\rfloor$，则另一个是$\lfloor n/2\rfloor - 1$此时算法运行的递归式为

$$
T(n) = 2T(n/2)+\Theta(n)
$$

其中$\Theta(n)$表示遍历当前数组的次数。那么由主定里的情况2，递归式的解为$T(n) = \Theta(n\lg n)$

### 平衡划分

快速排序的平均运行时间接近于最好情况而不是最坏情况。

假设划分总是产生$9:1$长度的数组，那么该递归式为
$$
T(n) = T(9n/10) + T(n/10) +cn
$$

我们在这里显式的写出$\Theta(n)$的常数c。在这里，树中每层递归的代价都是$cn$。第一层中，遍历时间为$cn$，第二层的元素分别有$1/10 n$个和$9/10 n$个，所以遍历的时间也是$cn$，以此类推直到最后一层。递归在$\log_{10/9} n - \Theta(\lg n)$处停止，所以总的时间是$\Theta(n\lg n)$。在这种极度不平衡的情况下的复杂度都是$O(n\lg n)$。实际上就算是$99:1$也可以得到同样的情况，只要每层的代价都是$O(n)$。

我们可以拓展，任意一种常数比例的划分产生深度为$\Theta(\lg n)$的递归树。这一步非常重要，因为最坏的情况一共有深度为$O(n)$的递归树。只要划分是常数比例的，运行时间总是$O(n\lg n)$