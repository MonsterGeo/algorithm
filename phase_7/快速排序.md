# 第7章-快速排序

快速排序是一种时间复杂度为$\Theta(n^2)$的排序算法，虽然最坏情况复杂度很差，但快排是实际排序应用中最好的选择，因为他的平均性能很好，期望时间复杂度是$\Theta(n\lg n)$。并且支持原址排序，甚至在虚存环境也可以很好工作。

## 快排描述

快速排序也使用了分治思想，下面是一个对典型子数组```A[p..r]``` 快速排序的三步分治过程：

首先，数组```A[p..r]```被划分为两个(可能为空)子数组```A[p..q-1]```和```A[q+1..r]```。使得 ```A[p..q-1]```中的每一个元素都小于等于```A[q]```，并且```A[q]```也小于等于```A[q+1..r]```中的每个元素，其中，计算下标```q```也是划分过程的一部分。

**解决：** 通过递归调用快速排序，对子数组```A[p..q-1]```和```A[q+1..r]```进行排序

**合并：** 因为子数组都是原址排序的，所以不需要合并操作，没有额外的空间开销，所以此时数组```A[p..r]```已经有序

下面是伪代码：

```
QUICKSORT(A, p, r)
1|  if p < r
2|     q = PARTITION(A,p,r) //q是返回前面严格排序后的数组的前一个元素地址，因为A[r]之前的元素都是严格小于A[r]的，但是没有做排序
3|     QUICKSORT(A,p,q-1)
4|     QUICKSORT(A,q+1,r)
```
为了排序一个数组```A```的全部元素，初始调用为```QUICKSORT(A,1,A.length)```。

算法的关键为```PARTITION```过程，它实现对```A[p..r]```的原址重排


```
PARTITION(A,p,r)
1|  x = A[r]
2|  i = p-1
3|  for j = p to r-1
4|      if A[j] <= x
5|          i = i+1
6|          exchange A[i] with A[j]
7|  exchange A[i+1] with A[r]
8|  return i+1
```

```PARTITION```总是选择一个```x = A[r]```作为主元，并围绕它来划分子数组```A[p..r]```。随着程序执行，数组被划分为4个区域(可能为空)。在3-6行的for循环的每一轮迭代的开始，每一个区域都满足一定的性质，我们将这些性质作为循环不变量:

1. 若 $p \leq k \leq i$，则```A[k] <= x```
2. 若$i+1 \leq k\leq j-1$，则```A[k] > x```
3. 若$k= r$，则```A[k] = x```

也就是说这个过程后的数组满足上面3条性质，它是这样排序的：

```
(a)
     |2 |8|7|1|3|5|6|4| (数组)
    i|pj|           |r| (位置)

(b) 对于过程(a), A[j] < A[r]，i = p-1 +1,p-1没有元素，因此不做任何改变，有
    |2  |8|7|1|3|5|6|4|
    |p i|j|         |r|

(c) 对过程(b)，A[j] > A[r] 跳过过程得到
    |2 |8|7|1|3|5|6|4|
    |pi|j|       |r|

(d) A[j] > A[r]，跳过
    |2 |8|7|1|3|5|6|4|
    |pi| |j|     |r|

(e) A[j] < A[r] => 1 < 4，i = i+1然后交换A[i]和A[j]

    |2|1|7|8|3|5|6|4|
    |p|i| |j|     |r|

(f) A[j] < A[r] => 3 < 4重复过程，得到

    |2|1|3|8|7|5|6|4|
    |p| |i|   |j| |r|

(g) A[j] > A[r] ，跳过
    |2|1|3|8|7|5|6|4|
    |p| |i|     |j|r|

(h) A[j] > A[r] 跳过

    |2|1|3|8|7|5|6|4  |
    |p| |i|       |j r|

(i) 现在j = r，循环结束，交换A[i+1]和A[r]，我们得到

    |2|1|3|4  |7|5|6|8|
    |p|   |i+1|   |r|
```
现在,i+1指向元素4，那么接着我们排序前面3个元素，即2,1,3，所以下一个数组带入```QUICKSORT(A,p,i)```，现在进入第二层递归，首先进入的p = 1小于i = 3，那么运行排序程序```PARTITION(A,p,i)```，由于3比前面2个元素都大，i不变，递归程序是```QUICKSORT(A,p,i-1)```，即元素2和1，运行排序程序，由于1比2小，交换位置得到```|1|2|```。返回i+1，也就是i。此时已经排序完毕，那么运行下一个层递归，即i+1到r的元素

代码：
```C
int Partition(int arr[],int p,int r)
{
    int x = arr[r];
    int i = p - 1;
    for (int j = p; j < r; j++)
    {
        if (arr[j] <= x)
        {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[r];
    arr[r] = temp;
    return i + 1;
}
void QuickSort(int arr[],int p, int r)
{
    if (p < r)
    {
        int q = Partition(arr, p, r);
        QuickSort(arr, p, q - 1);
        QuickSort(arr, q + 1, r);
    }
}

```

测试数组：```10 7 8 9 1 5```
结果：

```
Unsorted array: 
10 7 8 9 1 5
Sorted array:
1 5 7 8 9 10
```